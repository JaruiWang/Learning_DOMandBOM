## 同一组元素循环的排他思想算法
如果有同一组元素，我们想要实现某一个元素的某种样式，就需要使用循环的排他思想算法：1.先把所有元素全部清除样式；
2.再给当前的元素设置样式。```html
    <button>"按钮"</button>
    <button>"按钮"</button>
    <button>"按钮"</button>
    <button>"按钮"</button>
    <button>"按钮"</button>
    <button>"按钮"</button>
```
```js
    var bts=document.getElementsByTagName("button");
    //2.注册事件 ，注意bts是一系列的元素，bts[i].onclick
    for(var i=0;i<bts.length;i++){
        bts[i].onclick=function(){
            for(var i=0;i<bts.length;i++){
                //先清空每一个btn的背景色
                bts[i].style.backgroundColor='';
            }
            //再设置当前的按钮的背景颜色
            this.style.backgroundColor='blue';
        }
    }

```



## 自定义属性的操作
1.获取属性值
element.属性  获取内置的属性（元素本身自带的属性）
elememt.getAttribute('属性')：主要获得自定义的属性

```html js
    <div id="a1" index="zxccvb">

    </div>

    <script>
        var div=document.getElementById('a1');
        console.log(div.id);
     //   console.log(div.index);  获取失败了
        console.log(div.getAttribute('id'));  // 可以读取的，和div.i的一样
        console.log(div.getAttribute('index')); // 可以读取的
    </script>
```

2.设置属性值
element.属性="值"  设置内置属性值（元素本身自带的属性）
elememt.setAttribute('属性'，"值")：主要设置自定义的属性
```html js
    <div id="a1" index="zxccvb" class="classhaha">
    </div>

    <script>
        var div=document.getElementById('a1');
     div.id='a2';  //内置属性，直接用 element.属性="值" 来设置
   //  div.index='aaaaaa'; 自定义属性，直接设置无效
   div.setAttribute('index','aaaabb'); // 自定义属性，用setAttribute('属性'，"值")来设置
 //  div.setAttribute('class','class001');
 div.className='class002';  //注意class属性比较特殊，用div.className是使用className名字
                                //用div.setAttribute('class','class001'); 使用class名字
    </script>

```

3.移除属性
elememt.removeAttribute('属性')：移除属性,内置属性和自定义属性都可以移除
```js
   // 3.移除属性 removeAttribute(属性)
   div.removeAttribute('index');
   div.removeAttribute('class');

```

## H5自定义属性(存在兼容性问题：低版本的浏览器识别不了))
### 设置自定义属性的规范和要求
为了防止元素的内置属性和自定义属性混淆，引起用户的歧义
H5规定自定义属性需要用 data- 开头作为属性名并赋值。
比如<div data-index='1'></div>
或者使用JS设置
element.setAttribute('data-index',2)

### 新增的获取自定义属性的方法 element.dataset.属性
```js
    // h5新增的获取自定义属性的方法
    // dataset是一个集合里面存放了所有以data开头的自定义属性
    console.log(div.dataset)
    console.log(div.dataset.index)
    console.log(div.dataset['index'])
    //如果自定义属性里面有多个-链接的单词，我们获取的时候采用驼峰命名法
    //例如自定义属性data-list-name="andy"
    console.log(div.dataset.listName);
    console.log(div.dataset['listName']);
```


## 节点操作
获取元素通常由两者方法：
1. 利用DOM提高的方法获取元素
document.getElementBy()
document.getElemensBuTagName()
document.querySelector等
主要问题是每获取一个新的对象，都需要用一次document.操作
比较繁琐

2. 利用节点层级关系获取元素
利用父子兄关系获取元素
逻辑性强，但是兼容性稍差

两种方法都可以获取节点元素，后面都会使用，但是节点操作更加简单。

### 节点概述
一般地，节点至少拥有nodeType(节点类型)，nodeName(节点名称)和nodeValue(节点值)这三个基本属性
- nodeType
元素节点 nodeType为1
属性节点 nodeType为2
文本节点 nodeType为3（文本节点包括文字，空格，换行等）

在实际开发中，节点操作主要操作的是 **元素节点**

## 节点层级
### 父子节点
父子节点node.parentNode
```html
    <div class="demo">
        <div class="box" >123
            <span class="eweima">x</span>
        </div>
    </div>
```
```js
    var erweima=document.querySelector('.eweima');
    //得到的是离元素最近的父级节点(亲爸爸)
    //erweima.parentNode,获得的erweima父节点<div class="box" ></div>
    console.log(erweima.parentNode);

```

### 子节点
子节点 parentNode.childNodes
1.childNodes返回包含指定节点的子节点，包含 元素节点 文本节点等（**不常用**）

2.**children** 获取所有的子元素节点，比较常用
```js
    // 1.子节点  childNodes 所有的子节点 包含 元素节点 文本节点等。
    console.log(ul.childNodes);
    console.log(ul.childNodes[0].nodeType);
    console.log(ul.childNodes[1].nodeType);
    //childNodes想要获取单纯的子元素节点需要根据nodeType值来专门处理，比较麻烦，一般不推荐使用

    // 2.children 获取所有的子元素节点,也是实际开发过程中常用的
    console.log(ul.children);

```

### 获取第一个子节点和最后一个子节点
1.parentNode.firstChild
firstChild返回第一个子节点，找不到则返回null。同样也是包括所有的节点类型。

2.parentNode.lastChild
lastChild返回最后一个子节点，找不到则返回null。同样也是包括所有的节点类型。
```html
    <ol>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
    </ol>

```
```js
    var ol=document.querySelector('ol');
    console.log(ol.childNodes);
    
    //1.firstChild获取的第一个子节点，不管是第一个元素节点还是文本节点
    console.log(ol.firstChild);
    //1.lastChild获取的最后一个子节点，不管是最后一个元素节点还是文本节点
    // console.log(ol.lastChild);

    //2.firstElementChild获取的第一个元素子节点，但是有兼容性问题
    console.log(ol.firstElementChild);
    //2.lastElementChild获取的最后一个元素子节点，但是有兼容性问题
    console.log(ol.lastElementChild);

    //3.实际开发的写法，既没有兼容性问题又返回第一个元素
    console.log(ol.children[0]);
    //3.实际开发的写法，既没有兼容性问题又返回最后一个元素
    console.log(ol.children[ol.children.length-1]);

```

### 兄弟节点
node.nextSibling
nextSibling返回当前元素的下一个兄弟节点，找不到则返回null,
1. nextSibling 包含元素节点 或者文本节点等
2. nextElementSibling 下一个元素兄弟节点 (有兼容性问题，ie9以上才支持)
目前没有特别好的办法，可以自定义一个函数处理nextSibling返回值，删去非元素节点。
不常用
```js
    var div=document.querySelector('div');
    //nextSibling 下一个兄弟节点 包含元素节点 或者文本节点等
    console.log(div.nextSibling);
    //previousSibling 上一个兄弟节点 包含元素节点 或者文本节点等
    console.log(div.previousSibling);

    //nextElementSibling 下一个元素兄弟节点 (有兼容性问题，ie9以上才支持)
    console.log(div.nextElementSibling);
    //previousElementSibling 上一个元素兄弟节点，没有就是null (有兼容性问题，ie9以上才支持)
    console.log(div.previousElementSibling);

```


### 创建节点和添加节点
我们想要页面中添加一个新的元素，分为两步：1.创建元素；2.添加元素。
1. 创建节点（动态创建元素节点）
document.createElement('tagName')
tagName指定HTML元素。

2. 添加节点
(1)node.appendChild(child)
node.appendChild()方法将一个节点添加到指定父节点的子节点列表的末尾。
类似与CSS中的::after伪元素
(2)node.insertBefore(child,指定元素)
方法将一个节点添加到父节点的指定子元素节点的前面。
```html js
    <ul>
        <li id="a1">123</li>
    </ul>
    <script>
        var ul=document.querySelector('ul');
        //1.创建节点元素节点
        var li=document.createElement('li');
        //2.添加节点node.appendChild(child)
        ul.appendChild(li);
        //3.node.insertBefore(child,指定元素)
        var lili=document.createElement('li');
        var li123=document.getElementById('a1');
        ul.insertBefore(lili,li123);
     //   ul.insertBefore(lili,ul.children[0]);
    </script>
```


### 删除节点
node.removeChild(child)
node.removeChild()方法从DOM中删除一个子节点，返回删除的节点。
```html js
    <button>删除</button>
    <ul>
        <li>熊大</li>
        <li>熊二</li>
        <li>光头强</li>
    </ul>
    <script>
        //1.获取元素
        var ul=document.querySelector('ul');
        var btn=document.querySelector('button');
        //2.绑定事件，删除元素
        btn.onclick=function(){
            // 2.删除元素  node.removeChild(child)
            if (ul.children.length!=0){
                ul.removeChild(ul.children[0]);
            }else{
                alert("已经没有可以删除的元素。");
                btn.disabled=true;
            }
            
        }
    </script>
```


### 复制节点（克隆节点）
node.cloneNode()
node.cloneNode()方法返回调用该方法的节点的一个副本。
1. node.cloneNode();括号为空或者里面为false;浅拷贝，只复制标签，不复制内容。
2. node.cloneNode(true);括号为true 深拷贝，同时复制标签和内容。
```html js
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <script>
        var ul=document.querySelector('ul');
        //1. node.cloneNode();括号为空或者里面为false;浅拷贝，只复制标签，不复制内容。
        //2. node.cloneNode(true);括号为true 深拷贝，同时复制标签和内容。
        var lili= ul.children[0].cloneNode();
        ul.appendChild(lili);
    </script>

```

## js中操作字典的方法
```js

    var a_dic={name:'大猪蹄子',
        subject:'数学',
        score:0     
    }

   for(var k in a_dic){
    // k得到的是属性名
      a_dic[k]得到的是属性值
     }
```

## 三种动态创建元素的区别
- document.write()
- element.innerHTML
- document.createElement()
### document.write()比较少用
document.write()就是把标签放在页面的最后（body元素的最后一个子元素）
```html
    <button>点击</button>
    <p>abc</p>

    <script> 
    //   document.write('<p>aallaammaa</p>');
     var btn=document.querySelector('button');
     btn.onclick=function(){
        document.write('<p>aallaammaa</p>');
        //如果在页面加载完毕后，再调用document.write(),会刷新掉之前的页面
      }
    </script>
```

### element.innerHTML 
element.innerHTML是将内容写入到某个DOM节点，不会导致页面全部重绘。
innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂。
```js
//  使用字符串拼接的形式 运行效率非常低
    for(var i=0;i<3000;i++){
     inner.innerHTML+='<div style="width:100px; height:100px; border:1px solid; " href="javascript:;"></a>';
    }
// 使用数组拼接的形式  运行效率最高的
    var arr=[];
    for(var i=0;i<3000;i++){
        arr.push('<div style="width:100px; height:10px; border:1px solid; "> </div>');
    }
    inner.innerHTML=arr.join(" ");
```
### createElement()
createElement() 创建多个元素的效率稍微低一些，但是结构清晰
```js
    //  document.createElement() 创建元素  
    var create=document.querySelector('.create');
    for(var i=0;i<3000;i++){       
        var div=document.createElement('div');
        div.style.width='100px';
        div.style.height='100px';
        div.style.border='1px';     
        create.appendChild(div);
    }

```

## a标签空链接href=#与href=javascript:void(0)的区别
我们在使用a标签的空链接时，通常有三种写法：
1. 不写 <a href="">百度</a>
2. 写# <a href="#">百度</a>
3. 写 <a href=javascript:void(0)>百度</a>
这三种写法有如下的区别：
（1）a href ="" 默认打开的还是当前页面，会刷新一下重新打开。
（2）#包含了一个位置信息，默认的锚是 #top 也就是网页的上端。即是说，当 href=# 的空链接被点击时，页面会跳到最顶端。
（3）javascript:void(0) 仅仅表示一个死链接，当 href=javascript:void(0) 的空链接被点击时，页面不会有任何反应。
两者等效 <a href="javascript:;">百度</a>  和 <a href="javascript:void(0)">百度</a>

