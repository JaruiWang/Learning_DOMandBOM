## 注册事件概述
给元素添加事件，称为注册事件或者绑定事件
注册事件有两种方式：传统方式和方法监听注册方式。

## 传统注册方式
- 利用on开头的事件 onclick
- <button onclick="alert('aa123456')"></button>
- btn.onclick=function(){}
- 特点：注册事件的唯一性，同一个元素同一个事件只能设置一个处理函数，最后面注册的处理函数将会覆盖前面注册的处理函数

## 方法监听注册方式
- w3c标准 推荐方式
- addEventListener()它是一个方法，IE9以前不支持这个方法，可以用attachEvent()代替
- 特点：同一个元素同一个事件可以注册多个监听器
```html js
    <button>传统事件点击</button>
    <button>监听注册方式</button>
    <script>
        var btns=document.querySelectorAll('button');
        // 2.事件监听注册方式 addEventListener
        // （1）addEventListener里面的事件是字符串，必须加引号，而且不带on
        // (2) 同一个元素 同一个事件可以添加多个监听器（事件处理程序），会先后进行处理
        btns[1].addEventListener('click',function(){
            alert('aaaaaa');
        })
        btns[1].addEventListener('click',function(){
            alert('a2');
        })
    </script>
```


## 删除事件的方式(解绑事件)
1.传统注册方式
eventTarget.onclick=null
```html js
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
        var divs=document.querySelectorAll('div');
        //传统的方式解绑事件 eventTarget.onclick=null
        divs[0].onclick=function(){
            alert(123);
            divs[0].onclick=null;
        }
    </script>
```

2.使用addEventListener删除事件
eventTarget.removeEventListener(type,listener)
如果考虑需要删除事件，那么在注册时不能使用匿名函数，必须使用函数名。
```html js
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
        divs[1].addEventListener('click',fn) //里面的fn不需要调用加小括号
        function fn(){
            alert(222);
            divs[1].removeEventListener('click',fn);
        }     
    </script>
```

## DOM事件流
事件流描述的是从页面中接收事件的顺序。
事件发生时会在元素节点之间按照特点的顺序传统，这个传播过程就是DOM事件流。
DOM事件流分为3个阶段：
1. 捕获阶段，网景最早提出，从DOM最顶层节点开始，然后逐级往下传播到最具体元素接收的过程。
从上往下，从大到小，document->html->body-div
2. 当前目标阶段 div
3. 冒泡阶段，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程。
从下往上，从小到大， div->body->html->document

注意：
- JS代码中只能执行捕获或者冒泡其中的一个阶段
- onclick 和 attachEvent只能得到冒泡阶段
- addEventListener(type,listener[,useCapture])
第三个参数useCapture如果是true,表示在事件捕获阶段调用事件处理程序；
如果是false(不写默认是false),表示的是在事件冒泡阶段调用事件处理程序。

- 实际开发中我们很少使用事件捕获，我们更加关注事件的冒泡。
- 有些事件没有冒泡，比如onblur,onfocus,onmouseenter,onmouseleave。
```html js
    <div class="father">
        <div class="son">son盒子</div>
    </div>
    <script>
        // addEventListener(type,listener[,useCapture])
        // 第三个参数useCapture如果是true,表示在事件捕获阶段调用事件处理程序；
        // 点击时，先弹出father,再弹出son
        // var son=document.querySelector('.son');
        // son.addEventListener('click',function(){
        //     alert('son');
        // },true);
        // var father=document.querySelector('.father');
        // father.addEventListener('click',function(){
        //     alert('father');
        // },true);
        // JS代码中只能执行捕获或者冒泡其中的一个阶段

    // addEventListener(type,listener[,useCapture])
    // 第三个参数useCapture如果是false(不写默认是false),表示的是在事件冒泡阶段调用事件处理程序。
    // 点击时，先弹出son,再弹出father
        var son=document.querySelector('.son');
        son.addEventListener('click',function(){
            alert('son');
        },false);
        var father=document.querySelector('.father');
        father.addEventListener('click',function(){
            alert('father');
        },false);
    </script>

```

## 事件对象
1. event 就是一个事件对象，写到我们监听函数的小括号内，当作形参
2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数
3. 事件对象是我们事件的一些列相关数据的集合，跟事件相关的，
比如鼠标点击里面就包含了鼠标的相关信息，例如哪个对象绑定了事件，鼠标坐标等
如果是键盘事件里面就包含的键盘事件的相关信息，例如判断用户按下了哪个按键

4. 这个事件对象我们也可以自己命名，比如event,evt,e,aa,bb
5. 事件对象也有兼容性问题 ie678 通过window.event
6. 兼容性写法：e=e||window.event,但是现在一般不用考虑兼容性问题
```html
    <div>123</div>
    <script>
        //事件对象
    //     var div=document.querySelector('div');
    //     div.onclick=function(e){
    //    //     console.log(e);
    //         console.log(window.event);
    //     }

        var div=document.querySelector('div');
        div.addEventListener('click',function(bb){
            console.log(bb);
            
        })
        
    </script>


```

### e.target和event的区别

```html
    <ul>
        <li>aaa</li>
        <li>bbb</li>
        <li>ccc</li>
    </ul>
    <script>
        ul=document.querySelector('ul');
        ul.addEventListener('click',function(e){
            console.log(e.target);
            //e.target返回的是触发事件的对象元素
            //点击li元素内容，返回被点击的li
            console.log(this);
            // this返回的是事件绑定的对象元素
            // 点击li元素内容，返回的都是ul
        })
    </script>

```

### e.type
e.type返回的是事件的类型
```html js
    <ul>
        <li>aaa</li>
        <li>bbb</li>
        <li>ccc</li>
    </ul>
    <script>
        ul=document.querySelector('ul');
        ul.addEventListener('click',fn);
        ul.addEventListener('mouseover',fn);
        ul.addEventListener('mouseout',fn);
        function fn(e){
            console.log(e.type);  //点击li后，例如返回的是“click”,点击事件
        }
    </script>
```

### 阻止默认事件（默认行为）
阻止默认事件,让链接不跳转 或者 让提交按钮不提交,有三种方式：
（1）e.preventDefault(); 适合普通浏览器；
（2）e.returnValue; 低版本浏览器支持 ie678 returnValue属性
 (3) return false; 利用return false 也能阻止默认行为 没有兼容性问题return后面的代码不执行了，而且仅仅限于传统的注册方式。
       
```html
    <a href="http://www.baidu.com">百度</a>
    <form action="http://www.baidu.com">
        <input type="submit" value="提交" name="sub">
    </form> 
    <script>
        // 阻止默认行为（事件） 让链接不跳转 或者 让提交按钮不提交
        var a=document.querySelector('a');
        //1.用addEventListener来注册
        a.addEventListener('click',function(e){
            e.preventDefault();
        })

     //   2.用传统的注册方式
      a.onclick=function(e){
    //（1）普通浏览器还是用e.preventDefault();
         e.preventDefault();

    //   （2）低版本浏览器支持 ie678 returnValue属性
         e.returnValue;
        //(3) 利用return false 也能阻止默认行为 没有兼容性问题
        //return后面的代码不执行了，而且仅仅限于传统的注册方式
       return false;
       alert('abc');
      }
```


## 阻止事件冒泡
事件冒泡：开始时由最具体的元素接受，然后逐级向上传播到DOM最顶层节点。
事件冒泡本身的特点，会带来好处，也会带来坏处，需要我们灵活掌握。
阻止事件冒泡的写法：e.stopPropagation();(标准的写法，但是ie6-8不兼容)
ie6-8需要使用e.cancelBubble属性， e.cancelBubble=true;
```js
    // 阻止冒泡 dom推荐的标准  stopPropagation()
    // propagation 传播，繁殖
    var son=document.querySelector('.son');
    son.addEventListener('click',function(e){
        alert('son');
        e.stopPropagation();
        //   e.cancelBubble=true;
        // bubble 气泡
    },false);

```

## 事件委托
事件委托的核心原理，给父节点，添加监听器，利用事件冒泡影响每一个节点
利用e.target获得我们点击的对象
```html js
    <ul>
        <li>知否知否，点我有</li>
        <li>知否知否，点我有</li>
        <li>知否知否，点我有</li>
        <li>知否知否，点我有</li>
        <li>知否知否，点我有</li>
    </ul>
    <script>
        // 事件委托的核心原理，给父节点，添加监听器，利用事件冒泡影响每一个节点
        var ul=document.querySelector('ul');

        ul.addEventListener('click',function(e){
            // 利用e.target获得我们点击的对象
            e.target.style.backgroundColor='pink';
        })
    </script>

```

## 禁止鼠标右键菜单和禁止选中文字
1. contextmenu主要用于控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单。该事件在鼠标右键单击时触发。
2. 禁止选中文字 selectstart，该事件在鼠标选择文字时就触发了。
```html js
<body>
    我是一段不愿意分享的文字
    <script>
        // 1.contextmenu 我们可以禁用右键菜单
        document.addEventListener('contextmenu',function(e){
            e.preventDefault();
        })

        // 2.禁止选中文字 selectstart
        document.addEventListener('selectstart',function(e){
            e.preventDefault();
        })
    </script>
</body>

```


## 鼠标事件对象
event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象MouseEvent和键盘事件对象KeyboardEvent。
鼠标事件对象
e.clientX ，返回鼠标相对于浏览器窗口可视区的X坐标;
e.clientY，返回鼠标相对于浏览器窗口可视区的Y坐标;
e.pageX，返回鼠标相对于文档页面的X坐标；
e.pageY，返回鼠标相对于文档页面的Y坐标；
e.screenX，返回鼠标相对于电脑屏幕的X坐标；
e.screenY，返回鼠标相对于电脑屏幕的Y坐标；


## 常用键盘事件
- onkeyup,某个键盘按键被松开时触发
- onkeydown,某个键盘按键被按下时触发
- onkeypress,某个键盘按键被按下时触发，但是它不识别功能键，例如ctrl,shift和箭头。

注意三个事件的执行顺序：keydown -- keypress -- keyup
```html js
<script>
    // 传统的绑定方式
    // document.onkeydown=function(){
    //     console.log("按下了");
    // }

    //现在推荐的绑定方式
    document.addEventListener('keypress',function(){
        console.log("按下了keypress");
    })
    document.addEventListener('keydown',function(){
        console.log("按下了keydown");
    })
    document.addEventListener('keyup',function(){
        console.log("按下了keyup");
    })
</script>
```

## keyCode属性可以得到相应键的ASCLL码
```js
    // 键盘事件对象的keyCode属性可以得到相应键的ASCLL码
    // 1.我们的keyup和keydown事件并不区分字母大小写，按下a和A都是65
    // 2.keypress事件区分字母的大小写，按下a就是97，按下A就是65。
    document.addEventListener('keyup',function(e){
        //   console.log(e);
        console.log("keyup:"+e.keyCode);
    })

    document.addEventListener('keypress',function(e){
        //   console.log(e);
        console.log("keypress:"+e.keyCode);
    })
```



